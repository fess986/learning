const a = 10;
const b = 5;
let c;
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)
let ms = 1e-6; // шесть нулей, слева от 1
alert( 0xff ); // 255. 16-ричное значение, например для цветов
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
alert( a == b ); // true, с двух сторон число 255
alert( 1e500 ); // Infinity  -  слишком большое число - бесконечность
// Привет! Я – число, растущее само по себе!
alert( 9999999999999999 ); // покажет 10000000000000000. Проблема из за потери точности

alert( 0.1 + 0.2 == 0.3 ); // false - проблема из-за округления дробей

let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3 - для правильного расчета дробей их лучше округлять


c = a + b;
console.log (c);
c += 10;
console.log (c);
console.log (c+=5);
c++;
console.log (c);
console.log (a % 3);   //  остаток от деления на 3. Таким образом можно, например определять четность числа
console.log (b ** 3);  // возведение числа в степень
console.log (parseInt('10') / 2);  // конвертация строки в число
console.log (Math.sqrt(9));  //  Math  -  встроенный в js объект. Начинается с большой буквы
console.log('number'.length);  //  использование свойств и методов может быть напрямую, как к объекту "строка"
function ourRandomRange(ourMin, ourMax) {  //рандом из диапазона
  return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;
}
ourRandomRange(1, 9);
console.log(Math.pow(3, 2));  //возведение в  степень

//неочевидное поведение null в сравнениях
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 );

// Math.trunc - встроенная функция, которая удаляет десятичную часть
alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное

// ИСПОЛЬЗОВАНИЕ МЕТОДОВ ЧИСЕЛ
// округление до знака. Возвращается строка
let n = 1.23456;
alert( n.toFixed(2) ); // 1.23
let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой.

 //преобразование в другие системы счисления. в скобках указывается в какую
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
alert( 123456..toString(36) ); // 2n9c  -  самое большое основание. Используется для укорачивания длинных цифр. Если указана непосредственно цифра, используются 2 точки, чтобы JS понимал, что после первой точки не идет десятичная часть числа

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
alert( NaN === NaN ); // false -  NaN - уникален и не равен сам себе

// проверка можно ли строку перевести в число
let num = +prompt("Enter a number", '');
// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert( isFinite(num) );

// если нужно перевести в число хотя бы часть строки, которая начинается с числа, до первой ошибки
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

//второй аргумент в parseInt указывает систему счисления
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
alert( parseInt('2n9c', 36) ); // 123456

//правильное округление до 6,4 . Если
console.log(6.35.toFixed(1));  // 6,3  из за проблемы неточности
let a = 6.35 * 10;
a = Math.round(a) / 10;
console.log(a);  //6,4

//функция проверки введеного числа
function isnumber() {
  let testnumber = 'ass';
  while (isNaN(testnumber)) {
    testnumber = Number(prompt('input number'));
  }
  alert(testnumber);
}
isnumber();
